# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' American Option 1D (local volatility, penalty method)
#'
#' Prices an American option on a single equity with local volatility using operator splitting
#' and a penalty-projection method for the early exercise constraint.
#'
#' @param s_0 Stock spot price.
#' @param k Strike price.
#' @param tau Time to expiry (in years).
#' @param r_d Risk-free rate (domestic).
#' @param q Dividend yield.
#' @param sigma Local volatility matrix sampled on the grid.
#' @param type Either "call" or "put".
#' @param s_min,s_max Min/Max of the underlying prices grid.
#' @param n_s Number of intervals in the asset grid (n_s + 1 nodes).
#' @param n_t Number of time steps.
#' @param lambda Penalty parameter (> 1).
#' @param tolerance Relative error tolerance for the penalty iterations.
#'
#' @export
american_option_lv <- function(s_0, k, tau, r_d, q, sigma, type, s_min, s_max, n_s, n_t, lambda, tolerance) {
    .Call(`_LocalVolatility_american_option_lv`, s_0, k, tau, r_d, q, sigma, type, s_min, s_max, n_s, n_t, lambda, tolerance)
}

#' European Option 1D (local volatility)
#'
#' Prices a European option on a single equity with local volatility using a 1D Crank–Nicolson
#' finite-difference scheme, time-dependent boundaries, and linear interpolation at the spot.
#'
#' @param s_0 Stock spot price.
#' @param k Strike price.
#' @param tau Time to expiry (in years).
#' @param r_d Risk-free rate (domestic).
#' @param q Dividend yield.
#' @param sigma Local volatility matrix sampled on the grid; commonly (n_s + 1) x (n_t + 1) or
#'   (n_s + 1) x n_t depending on solver indexing.
#' @param type Either "call" or "put".
#' @param s_min,s_max Min/Max of the asset grid.
#' @param n_s Number of intervals in the asset grid (n_s + 1 nodes).
#' @param n_t Number of time steps.
#'
#' @export
european_option_lv <- function(s_0, k, tau, r_d, q, sigma, type, s_min, s_max, n_s, n_t) {
    .Call(`_LocalVolatility_european_option_lv`, s_0, k, tau, r_d, q, sigma, type, s_min, s_max, n_s, n_t)
}

#' American Option 2D (local volatility, penalty method)
#'
#' Prices an American option on an equity in a foreign currency with local volatilities for both S and X.
#' Uses operator splitting and a penalty-projection scheme for the obstacle.
#'
#' @param s_0 Stock spot price.
#' @param x_0 FX spot price (domestic per foreign).
#' @param k Strike price (domestic currency).
#' @param tau Time to expiry (in years).
#' @param r_d Risk-free rate (domestic).
#' @param r_f Risk-free rate (foreign).
#' @param q Dividend yield.
#' @param sigma_s Local volatility matrix for the stock of size (n_s + 1) x n_t.
#' @param sigma_x Local volatility matrix for the FX of size (n_x + 1) x n_t.
#' @param rho Correlation between the stock and the FX in `[-1, 1]`.
#' @param type Either "call" or "put".
#' @param s_min,s_max Min/Max of the stock grid.
#' @param x_min,x_max Min/Max of the FX grid.
#' @param n_s Number of intervals in stock grid (n_s + 1 nodes).
#' @param n_x Number of intervals in FX grid (n_x + 1 nodes).
#' @param n_t Number of time steps.
#' @param alpha Grid clustering parameter for Tavella–Randall grids (> 0).
#' @param lambda Penalty parameter (> 1).
#' @param tolerance Relative error tolerance for the penalty fixed-point iterations.
#'
#' @details
#' Domestic-measure drift and discounting as in the constant-vol case, using local pointwise vols:
#' mu_S = r_f - q - rho * sigma_S * sigma_X in S, r_d - r_f in X, discounting at r_d. Far-field
#' boundaries use exp(-q * tau) on S·X and exp(-r_d * tau) on K.
#'
#' @export
american_option_lv_2d <- function(s_0, x_0, k, tau, r_d, r_f, q, sigma_s, sigma_x, rho, type, s_min, s_max, x_min, x_max, n_s, n_x, n_t, alpha, lambda, tolerance) {
    .Call(`_LocalVolatility_american_option_lv_2d`, s_0, x_0, k, tau, r_d, r_f, q, sigma_s, sigma_x, rho, type, s_min, s_max, x_min, x_max, n_s, n_x, n_t, alpha, lambda, tolerance)
}

#' American Option 2D (constant volatility, penalty method)
#'
#' Prices an American option on an equity quoted in a foreign currency using a 2D finite-difference PDE
#' with Yanenko operator splitting and a penalty-projection scheme for the early exercise constraint.
#'
#' @param s_0 Stock spot price.
#' @param x_0 FX spot price (domestic per foreign).
#' @param k Strike price (domestic currency).
#' @param tau Time to expiry (in years).
#' @param r_d Risk-free rate (domestic).
#' @param r_f Risk-free rate (foreign).
#' @param q Dividend yield.
#' @param sigma_s Constant volatility of the stock.
#' @param sigma_x Constant volatility of the FX.
#' @param rho Correlation between the stock and the FX in `[-1, 1]`.
#' @param type Either "call" or "put".
#' @param s_min,s_max Min/Max of the stock grid.
#' @param x_min,x_max Min/Max of the FX grid.
#' @param n_s Number of intervals in stock grid (n_s + 1 nodes).
#' @param n_x Number of intervals in FX grid (n_x + 1 nodes).
#' @param n_t Number of time steps.
#' @param alpha Grid clustering parameter for Tavella–Randall grids (> 0).
#' @param lambda Penalty parameter (> 1).
#' @param tolerance Relative error tolerance for the penalty fixed-point iterations.
#'
#' @details
#' Domestic-measure drift and discounting are applied (mu_S = r_f - q - rho * sigma_s * sigma_x in S,
#' r_d - r_f in X, discounting at r_d). Far-field Dirichlet boundaries use exp(-q * tau) on S·X and
#' exp(-r_d * tau) on K. The penalty parameter is split across the two sub-steps.
#'
american_option_2d <- function(s_0, x_0, k, tau, r_d, r_f, q, sigma_s, sigma_x, rho, type, s_min, s_max, x_min, x_max, n_s, n_x, n_t, alpha, lambda, tolerance) {
    .Call(`_LocalVolatility_american_option_2d`, s_0, x_0, k, tau, r_d, r_f, q, sigma_s, sigma_x, rho, type, s_min, s_max, x_min, x_max, n_s, n_x, n_t, alpha, lambda, tolerance)
}

#' European Option 2D (local volatility)
#'
#' Prices a European option on an equity in a foreign currency using a 2D finite-difference PDE
#' with time- and state-dependent local volatilities for both S and X.
#'
#' @param s_0 Stock spot price.
#' @param x_0 FX spot price (domestic per foreign).
#' @param k Strike price (domestic currency).
#' @param tau Time to expiry (in years).
#' @param r_d Risk-free rate (domestic).
#' @param r_f Risk-free rate (foreign).
#' @param q Dividend yield.
#' @param sigma_s Local volatility matrix for the stock of size (n_s + 1) x n_t.
#' @param sigma_x Local volatility matrix for the FX of size (n_x + 1) x n_t.
#' @param rho Correlation between the stock and the FX in `[-1, 1]`.
#' @param type Either "call" or "put".
#' @param s_min,s_max Min/Max of the stock grid.
#' @param x_min,x_max Min/Max of the FX grid.
#' @param n_s Number of intervals in stock grid (n_s + 1 nodes).
#' @param n_x Number of intervals in FX grid (n_x + 1 nodes).
#' @param n_t Number of time steps.
#' @param alpha Grid clustering parameter for Tavella–Randall grids (> 0).
#'
#' @details
#' Domestic-measure drift and discounting are applied as in the constant-vol solver, but with
#' pointwise volatilities. In the S-direction, mu_S = r_f - q - rho * sigma_S * sigma_X (local).
#' In the X-direction, drift is r_d - r_f. Far-field Dirichlet boundaries use exp(-q * tau) on S·X
#' and exp(-r_d * tau) on K. When `sigma_s` and `sigma_x` are constant-valued matrices, prices
#' should match the constant-vol solver up to numerical tolerance.
#'
#' @export
european_option_lv_2d <- function(s_0, x_0, k, tau, r_d, r_f, q, sigma_s, sigma_x, rho, type, s_min, s_max, x_min, x_max, n_s, n_x, n_t, alpha) {
    .Call(`_LocalVolatility_european_option_lv_2d`, s_0, x_0, k, tau, r_d, r_f, q, sigma_s, sigma_x, rho, type, s_min, s_max, x_min, x_max, n_s, n_x, n_t, alpha)
}

#' European Option 2D (constant volatility)
#'
#' Prices a European option on an equity quoted in a foreign currency using a 2D finite-difference PDE
#' with Yanenko operator splitting, constant volatilities (sigma_s, sigma_x), and a centered mixed-derivative.
#'
#' @param s_0 Stock spot price.
#' @param x_0 FX spot price (domestic per foreign).
#' @param k Strike price (domestic currency).
#' @param tau Time to expiry (in years).
#' @param r_d Risk-free rate (domestic).
#' @param r_f Risk-free rate (foreign).
#' @param q Dividend yield.
#' @param sigma_s Constant volatility of the stock.
#' @param sigma_x Constant volatility of the FX.
#' @param rho Correlation between the stock and the FX in `[-1, 1]`.
#' @param type Either "call" or "put".
#' @param s_min,s_max Min/Max of the stock grid.
#' @param x_min,x_max Min/Max of the FX grid.
#' @param n_s Number of intervals in stock grid (n_s + 1 nodes).
#' @param n_x Number of intervals in FX grid (n_x + 1 nodes).
#' @param n_t Number of time steps.
#' @param alpha Grid clustering parameter for Tavella–Randall grids (> 0).
#'
#' @details
#' Domestic-measure drift and discounting are applied. In the S-direction, the drift is
#' mu_S = r_f - q - rho * sigma_s * sigma_x. In the X-direction, the drift is r_d - r_f, and
#' discounting is at r_d. Far-field Dirichlet boundaries use exp(-q * tau) on the S·X term and
#' exp(-r_d * tau) on K. The spot (s_0, x_0) price is obtained via bilinear interpolation.
#'
#' @export
european_option_2d <- function(s_0, x_0, k, tau, r_d, r_f, q, sigma_s, sigma_x, rho, type, s_min, s_max, x_min, x_max, n_s, n_x, n_t, alpha) {
    .Call(`_LocalVolatility_european_option_2d`, s_0, x_0, k, tau, r_d, r_f, q, sigma_s, sigma_x, rho, type, s_min, s_max, x_min, x_max, n_s, n_x, n_t, alpha)
}

#' European Option 2D (closed-form, ADR)
#'
#' Closed-form Black–Scholes price for a European option on an ADR whose
#' underlying is the product S·X scaled by the ADR ratio n: ADR = (S·X)/n.
#' Assumes constant volatilities for S and X and correlation rho. The
#' effective ADR log-volatility is
#'   sigma_adr = sqrt(sigma_s^2 + sigma_x^2 + 2 * rho * sigma_s * sigma_x).
#'
#' The domestic-measure discounting is used: SX leg discounted by exp(-q * tau),
#' strike leg by exp(-r_d * tau). Note r_f does not enter the closed form directly
#' but is kept for API symmetry with PDE solvers.
#'
#' @param s_0 Stock spot price S(0).
#' @param x_0 FX spot price X(0) (domestic per foreign).
#' @param k Strike price (domestic currency).
#' @param tau Time to expiry (in years, > 0).
#' @param r_d Risk-free rate (domestic).
#' @param r_f Risk-free rate (foreign) — kept for signature symmetry.
#' @param q Dividend yield for the equity.
#' @param sigma_s Constant volatility of the stock.
#' @param sigma_x Constant volatility of the FX.
#' @param rho Correlation between the stock and the FX in `[-1, 1]`.
#' @param n ADR ratio (shares per ADR), usually >= 1.
#' @param type Either "call" or "put" (case-insensitive).
#'
#' @return Option price as a numeric scalar.
#'
#' @details
#' This is the standard Black–Scholes formula applied to ADR = (S·X)/n with
#' log-normal dynamics under the domestic measure. Let ADR_0 = (s_0 * x_0)/n and
#' sigma_adr as above. Then
#'   `d1 = [ln(ADR_0 / K) + (r_d - q + 0.5 * sigma_adr^2) * tau] / (sigma_adr * sqrt(tau))`,
#'   `d2 = d1 - sigma_adr * sqrt(tau)`.
#' The call is ADR_0 `e^{-q tau} N(d1) - K e^{-r_d tau} N(d2)`; the put uses put-call parity.
#'
#' @examples
#' european_option_cf_2d(100, 20, 2000, 1, 0.05, 0.02, 0.01, 0.2, 0.1, 0.3, 1, "call")
#'
#' @export
european_option_cf_2d <- function(s_0, x_0, k, tau, r_d, r_f, q, sigma_s, sigma_x, rho, n, type) {
    .Call(`_LocalVolatility_european_option_cf_2d`, s_0, x_0, k, tau, r_d, r_f, q, sigma_s, sigma_x, rho, n, type)
}

#' Generate a sequence based on the Tavella and Randall method
#'
#' This function generates a sequence of numbers following the Tavella and Randall method,
#' which applies a combination of hyperbolic sine transformations to create a smooth sequence
#' between a specified minimum and maximum value.
#'
#' @param x0 Numeric. The central value around which the sequence is generated.
#' @param alpha Numeric. A scaling parameter that controls the shape of the sequence.
#' @param x_min Numeric. The minimum value of the sequence.
#' @param x_max Numeric. The maximum value of the sequence.
#' @param n Integer. The number of values in the generated sequence.
#'
#' @return A numeric vector of length `n` containing the generated sequence.
#'
#' @details The function calculates the sequence by dividing the interval `[0, 1]` into `n`
#' equally spaced points. At each point, it computes the corresponding value based on the
#' Tavella and Randall method, which uses the hyperbolic sine function to ensure a smooth
#' transition between `x_min` and `x_max`.
#'
#' @export
tavella_randall <- function(x0, alpha, x_min, x_max, n) {
    .Call(`_LocalVolatility_tavella_randall`, x0, alpha, x_min, x_max, n)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call(`_LocalVolatility_RcppExport_registerCCallable`)
})
